# 1.	자바 개발 환경 구축
1)jdk설치- http://java.sun.com
-	j2se : Standard Edition [Core and Desktop]
-	j2ee : Enterprise Edition [Servlet/JSP/EJB…]
-	j2me : Mobile

2)  jdk6.0 -----bin : 컴파일러, 인터프리터 등 기타 개발 및 실행도구들 
             +-- demo: 데모 코드들
             +-- include
             +-- include-old : Native Code를 위한 C헤더 파일들
             +-- jre (Java Runtime Environment) : 개발도구를 제외하고 실행에 필요한 최소한의 환경만을 제공
             +-- lib : 실행파일들에 의해 사용되는 파일들

3)jdk환경변수 설정
제어판-시스템-고급-환경변수-새로만들기
  ㄱ)path설정 : C:\Java\jdk1.5.0_06\bin
  ㄴ)classpath설정 : . 

# 2.	자바의 역사
1)	1991년 sun사 Green Project 출범-James Gosling을 주축으로 Oak라는 언어 개발
   [가전기기에서 사용할 목적] 하드웨어 독립적인 언어로 구상됨
2)	1995년 : sun사와 netscape사 협약
3)	1996년 : 자바 지원 netscape 2.0 발표
4)	1997년 : jdk1.1 발표
5)	1998년 : jdk1.2 발표
6)	2000년 : jdk1.3 발표
7)	최근   : jdk1.4/ 5.0 / 6.0beta버전 발표

# 3.	자바의 특징
1)	플랫폼 독립성 : JVM(Java Virtual Machine)이 해당 플랫폼마다 
					제공되어져,
                    이를 설치하면 어떤 운영체제에서 작성된 자바 
					파일이든지 동일한 실행을 제공한다.
2)	객체 지향언어 : 재사용성, 유연성, 프로그램 생산성 향상
3)	멀티 스레드 지원 : Thread는 Process보다 작은 단위로 동시 
					   다발적으로 작업 수행이 가능.
4)	자동 메모리 관리-Garbage Collector(쓰레기 수집기)
5)	동적인 성능 확장 제공: Applet

# 4. 자바의 주석 처리 방법
//단문 주석
/* 
복문 주석
*/
/** 문서화 주석: javadoc를 이용해서 API문서를
				 작성하고자 할 때 사용
*/
# 5. 클래스 구조###########################
1) 패키지 선언: 최상단에 위치)import문 보다도
					먼저 와야 한다.
2. import 문 : 사용하고자 하는 패키지 경로를
				 기재
3. class 선언 : class키워드로 선언하고 클래스
		  이름을 기재.
		  이 때 주의. 클래스명==파일명
{
	4. 속성(멤버 변수) 선언 및 초기화
	    ex) int a=10;
        5. 생성자(멤버 변수의 초기화): 객체를
					생성할 때 호출된다.
					생성자이름==클래스명
					반환타입이 없다.
		ex)public Hello(){
			  a=20;
		   }
	6.  메소드 선언
	    1)p_s_v_main(String args[]){  }
		  : 실행시 제일 먼저 JVM에서 호출해주는
		    메소드. 프로그램 시작이자 끝이 된다.

		2)사용자 정의 메소드	
		  public int myFunction(int a){
				메소드가 하는 일
				ex)
				this.a=a;
				return a;
		}
		public void mySub(){

		}
}
# 6.변수란?

   1) 값을 담는 바구니라고 생각하자.
       즉 변수란 값을 저장하는 공간의 위치를 의미.
   
   2) 변수의 종류
       ㄱ)멤버변수(instance 변수)
	       ex) int a=10; 
		   **객체명으로 접근해야 한다.

	   ㄴ)클래스변수(static 변수)
			ex) static int b=10;
			**클래스명으로 접근해야 한다.

	   ㄷ)지역 변수(local 변수, automatic변수)

	   **자바의 지역변수는 반드시 초기화하고 
	     사용해야 함.
		 멤버와 클래스변수는 초기화 안해도
		 디폴트 값이 들어간다.

   3) 변수의 명명 규칙

      - 영문자와 숫자를 섞어 쓸 수 있으나,
	    숫자로 시작되어선 안된다.
      - 한글/한자도 변수명으로 사용가능
	  - 특수문자는 변수로 사용할 수 없다.
	    단, 언더바(_), $는 식별자로 사용 가능
      - 변수명은 명사형으로 지으며,
	    소문자로 시작. 

	4) 잘못된 변수 선언의 예
	   - int 9nine : 숫자로 시작 불가
	   - int hey&bar: &라는 특수문자 사용 불가
	   - int char : 예약어는 사용 불가
	   **keyword->교재 p56참조

	   다음변수는?
	   - int 변수=10;
	   - int $$$=20;
	   - int _myVar=30;
	   ---> 모두 사용 가능.

# 7. 자바의 자료형
	
	1) Primitive Type : 기본 자료형
	2) Reference Type : 참조형 ex) String s="Hi";
			|			String s=new String("Hi");
			|			MyDemo md = new MyDemo();
			|
			+--ㄱ) 클래스형
			+--ㄴ) 인터페이스형
			+--ㄷ) 배열
	                      
   1) Primitive Type
	   | 
       + ㄱ) 수치형--정수형----byte-->1byte ->8bit(byte a = 1 -> 00000001),(-2^7)부터(2^7-1)까지가 범위다.
	   |			|	+------short--->(2byte)-->(-2^15)~(2^15-1)
	   |			|   +------int--->(4byte)-->(-2^31)~(2^31-1)  (정수의 default값)
	   |			|	+------long--->(8byte)-->(-2^63)~(2^63)
	   |			|
	   |			|-실수형
	   |				+-----float--->(4byte)
	   |				+-----double--->(8byte)  (실수의 default값)
	   |
	   +ㄴ) 문자형 - char  (2byte)  : '가' 'A' '\u0000'
	   |			           0~ 65535[16비트]
	   |                        ex) char ch = '가';(문자열인경우--> "" 문자인경우--> '')
	   +ㄷ) 논리형 - boolean : true, false
	                       ex) boolean  b = true;

# 8. 자바의 연산자 종류

1) 분리자 : . [] () ; ,

2) 단항 연산자: 항이 하나인 연산자
       ㄱ)증감연산자 : ++  --
	   ㄴ)부호연산자 : +  -
	   ㄷ)비트별 NOT연산자 : ~
	   ㄹ)논리 부정 연산자 : !

3) 산술 연산자 : * / % + -
4) 쉬프트연산자 : <<  >>  >>>
5) 비교 연산자 : <  <=  >  >=  instanceof
6) 비트 연산자 : &  ^  |
7) 논리 연산자 : &&   ||
8) 조건 연산자 : ?:
9) 할당 연산자 : =  +=  *=  /=  -=  
                 <<=  >>=  >>>=  &=  ^=  |=


# 제어문
------------------------------------------------------
주제어문	1) 분기문 : if문, 
						if~else문
						if~ else if문(다중if문)
						switch~case문
			2) 반복문 : for루프문
						while루프문
						do~while루프문
-------------------------------------------------------
보조 제어문 1) break, break 라벨명
			2) continue, continue라벨명
			* 보조제어문은 단독으로는 사용 못하고
			주 제어문과 함께 사용한다.
-------------------------------------------------------

# 배열.[array]
 [1] 배열이란?
		...동종의 데이터들을 묶어 저장해놓은 자료구조.
			같은 종류의 자료들을 하나의 데이터 구조에 번호(인덱스)를 매겨
			저장하는 방식을 의미.
			이런 방법은 데이터의 저장, 정렬, 검색을 유용하게 할 수 있어 편리하다.
 [2] 배열의 특징
		- 기본자료형, 참조형 모두 저장 가능
		- 동종의 데이터만 저장 가능
		- 고정 크기

 [3] 배열 사용 방법
		1) 선언				double [] darr;double darr[]; (자료형 [] 배열변수명; or 자료형 배열변수명[];)
		2) 메모리 할당	darr new double[100];
		3) 초기화			darr [0] = 10.0;
								darr [1] = 20.1;
								....
		**1차원 배열**
			데이터형 배열명 [] = new 데이터형[배열크기];
				ex) int arr[] = new int[3];
		**2차원 배열**
		ex) int arr[][] = new int[2][3];//2행 3열

		
** 용어 정리***********
-클래스 : 객체를 만들어내는 틀 ex)붕어빵틀
-객체(object): 클래스를 통해 만들어 낸 구현물 
				ex)붕어빵
-속성 : 객체가 만들어질 때 특성화한 객체의 성질
		-->멤버변수로 표현 : has a 관계
         ex) 붕어빵 앙꼬
-행위 : 객체가 할 수 있는 기능-->메소드로 표현
**OOP란?***************

1. 구조적 프로그래밍, 절차지향 프로그래밍
	ex] C 프로그래밍
   : 일을 처리하는 순서와 과정을 프로그래밍으로 구현한 것.
	- Procedure, Process를 중시함
	- 순서, 과정이 달라지면 새로운 작업 모델이 필요함
	- 재사용성 불가

	반면 OOP는
	프로세스 중심이 아닌 객체 중심으로 프로그래밍 하는 것.
	-모듈화, 재사용이 좋다.

2. Object Oriented Programming
	ex]C++, Java 프로그래밍

   : 인간의 현실세계를 프로그램에 반영한 것. 즉, 
     현실세계에 존재하는
     object(객체,물체) 개념을 Program에 반영한 것

1) object : 물건, 물체를 의미.
           유무형의 물체.
		   ex) 집, 사람, 컴퓨터
		       정치, 경제, 사회, 공기...


2) object의 특징: 객체는 속성과 행위(행동양식)를 갖는다.
		  ex) 
		 따라서 프로그램에 객체를 반영할 때는
		 먼저 속성과 행동양식을 뽑아내는 과정이
		 필요한데...이를  객체 모델링이라 한다.

-OOP 순서
1) 프로그램에 필요한 객체를 뽑아냄 -ex)집
2) 객체 모델링 -ex)방, 세를 준다.
3) 클래스 구성 - class House
							{
								int room;
								public void rent(int price){}
							}
5) 객체 생성 및 사용
						House h = new House();
						h.rent(100);


3. OOP의 주요 특징(!!!!!!!!!!!4가지 주요 특징은 반드시 알아두자!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!)

        1. 추상화 - Abstraction
        2. 은닉성(캡슐화) - Encapsulation
        3. 다형성 - polymorphism
        4. 상속성 - Inheritance

- object를 프로그램에 반영하는 작업을 추상화라고 함

1. 추상화(Abstraction)란?
   ...어떤 물체(object)에서 주된 특징을 부각시켜 
	  표현하고, 나머지 부분은 과감하게 생략하는 것

	  OOP에서 사용되는 추상화도 이와 비슷하다.
	  한 물체를 대표하는 속성(명사)과 기능(동사)
	  를 추출해내는 것을 프로그래밍에서는 추상화
	  라고 한다.
	  ex) 집을 프로그래밍으로 추상화해보면...

	  House
	    |-속성(attribute): 방수, 주인이름, 지붕색...
		+-행위(behavior) : 세를 놓다. 수리하다. 
							청소하다. 사다. 팔다....
	   위의 속성은 멤버변수로...
	        행위 또는 기능은 메소드로 표현한다.

	위의 집이란 객체를 자바 프로그램에 추상화해보면
	class House
	{
		int room;
		String ownerName;
		String addr;

		public void existAt(String addr){  
			System.out.println(addr+"에 위치하다");
		}
	}
	class HouseTest
	{
		public static void main(String args[]){
			House h=new House();
			h.existAt("300번지");

			House h2=new House();
			h2.existAt("100번지");


		}
	}////////////////////////////

2. 은닉화(Encapsulation)
   - data를 캡슐화하고
   - data에 접근할 때는 메소드로...
     [setXXX()/getXXX()]

3. 다형성(Polymorphism)
	1) 오버로딩(Overloading)
		[생성자 오버로딩, 메소드 오버로딩]
		...메소드 이름을 동일하게 주되
		    매개변수의 데이터 타입과, 갯수, 순서를
			다르게 주어서 구성하는 것
			: 중복정의/ 다중정의

			**오버로딩 조건****

			- 오버로딩하려는 메소드 이름이 같아야
			- 메소드의 매개변수의 데이터형이
			  다르거나, 갯수가 다르거나, 순서가
			  달라야 한다.
			- 메소드의 반환타입은 신경 안써도 됨
			  (같아도 되고 달라도 됨)

	2) 오버라이딩(Overriding)
	    ...상속 개념과 맞물려 사용
		   부모로부터 상속 받은 메소드를
		   재정의해서 사용하는 것
			: 재정의
		**오버라이딩 조건******************
		- 오버라이드 하려는 메소드가 부모 클래스
		  에 존재해야 한다.
		- 메소드 이름이 동일해야 한다.
		- 메소드의 매개변수 갯수, 데이터타입이
		  같아야 한다.
		- 메소드의 반환타입도 같아야 한다.
		- 메소드의 접근 지정자는 부모클래스와
		  동일하거나, 접근 범위가 넓어야 한다.
	    - Exception의 경우 부모 클래스의 메소드와
		  동일하거나 더 구체적인 Exception을
		  발생시켜야 한다.

	3) 그 외 개념은 후에 설명...
///////////////////////////////////////////////
	1) Overloading
		
		i)생성자 오버로딩
			-생성자란?
			 : 객체가 생성될 때 최초로 실행되는
			   메소드를 의미.
		    
			-생성자 구성시 유의할 점
			 
			 a) 생성자 이름은 클래스명과 동일하게
			 b) 반환타입을 가져선 안된다.
			 c) 생성자의 접근지정자로는
			     public, protected, 생략형,private
				 모두 가능하나, 대부분 public속성
				 을 많이 준다.
				 cf)Math 클래스의 경우 생성자에
					private 지정자를 두고 있다.

			-생성자의 주요 역할
			: 멤버 변수를 초기화 하는 일
			-사용자가 생성자를 구현하지 않았을 경우
			 -->컴파일러는 default생성자를 제공해줌

			 ※ 그러나 사용자가 생성자를 하나라도
			    구현했다면, 그 때는 컴파일러가 제공
				해주는 기본생성자는 사라진다.

			-자바에서는 생성자를 다양하게 오버로딩
			 함으로써 다양한 초기값을 부여하고 있다.

			ii) 생성자 안에서 this()의 사용

			-this()는 자기 자신의 생성자를 호출하는
			 메소드

			-한 클래스 안에 여러 개의 생성자가
			  오버로딩된 형태로 존재하고,
			  그 기능이 유사할 때, this라는 키워드
			  를 이용해서 자기 자신의 다른 생성자를
			  호출할 수 있다.

		    - 이 때 주의할 점...

			  ㄱ)this()는 생성자 안에서만 호출해야
			     한다.
			
			  ㄴ)this()를 호출할 때는 반드시
			     생성자의 첫번째 문장이어야 한다.

              ㄷ)또한 생성자 안에서 this()와 super()
			     를 함께 쓸 수 없다.

	※ this 의 사용******************************
	1) this.변수 : 자기클래스의 멤버변수(인스턴스
				   변수)를 접근할 때 사용
	2) this.메소드: 자기 클래스의 멤버 메소드를
				    접근할 때 사용
	3) this() : 자기 자신의 생성자 호출 시 사용

	*** this 라는 키워드는 static 메소드안에서는
	    사용할 수 없다.
**************************************************
실습문제]
좌표를 나타내는 Point클래스를 설계해보자.
1. 클래스이름: Point
2. 멤버변수: x, y좌표를 기억시킬 변수
3. 2의 멤버변수를 캡슐화한다.
4. 캡슐화한 변수에 접근할 set/get계열 메소드를 구성한다.
5. Point클래스의 생성자를 구성한다.
...3가지 형태로 오버로딩해보자.
6. this()를 이용해서 멤버변수 값을 초기화하자.
7. 메소드 구성: 
1) Point클래스의 x, y좌표값을 증가 감소시켜주는 메소드
2) x와 y값이 같은지를 비교하는 메소드
를 구성해보자.
8. main()메소드를 갖는 PointTest클래스를 만들어
    Point객체 생성해 자기가 구성한 메소드를 호출해보자.

**********************************************
     ※ super 의 사용*****************************
	1) super.변수 : 부모클래스로부터 물려받은 변수
	2) super.메소드:   "              "      메소드
	3) super() : 부모클래스의 생성자
				..super()역시 생성자 안에서만 호출
				  가능하며, 생성자의 맨 첫줄에 위치
				  해야 한다.
				  super 라는 키워드도 static 메소드
				  안에서 사용 불가.
	super() 는 부모클래스에 생성자가 오버로딩된
	형태로 여러 개 존재할 때 그 중에서 어떤 생성자
	를 호출할 지 결정할 수 있다.

	**그러나 super()생성자를 사용자가 명시적으로 
	  호출하지 않는다면, 컴파일러는 자식클래스
	  생성자에서 super()의 디폴트 생성자를 자동
	  으로 호출한다.
	  ----------------------------------------
	  ex)
	      class Parent
	      {
			  String name;
			  public Parent(String n){
				  name=n;
			  }//인자 생성자----
	      }//////////////////
		  class Son extends Parent
		  {
			  public Son(){
				  super("아무개");
				  //만일 위 문장이 없다면 에러발생
				  //컴파일러가 super()를 자동호출
				  //하므로...
			  }//---------
		  }////////////////////

**************************************************

**********************************************
4. 상속성(Inheritance)
  : 기존 클래스에 작은 기능이나 특성을 추가하여
    새로운 클래스로 만드는 것을 의미.
	
	즉 부모클래스를 만들고, 그 부모클래스에
	있는 속성과 기능을 자식클래스에서 상속받아,
	새로운 기능과 속성을 추가하는 것.

	-상속 개념을 적용함으로써 개발시간 단축,
	 재사용성 등에 놀라운 장점이 있다.

-------------+		+--------------+                                   
Person       |      |Student	   |
-------------+ <----+--------------+
-name: String|		| - subject	   |
-age : int   |		|   : String   |
-------------+		+--------------+
	|
	|
-------------+     상속관계는 "is a" 관계가
Staff        |		성립할 때 맺을 수 있다.
-------------+      ex) Student is a Person
-dept: String|			Staff is a Person
             |			Teacher is a Person
-------------+

**자바에서 상속을 받을 때는 extends 란 키워드
  를 사용한다.
  자바는 단일 상속 개념이므로 extends 로 상속
  받을 수 있는 클래스는 단 하나뿐이다.
/////////////////////////////////////////////

5. 패키지(package)란?
...1) 클래스들 + 인터페이스들 
	  의 집합
   2) 패키지를 사용하는 이유
      i)  관리의 용이성
	  ii) 배포의 목적
   3) 패키지는 유사한 기능을 가진 클래스와 인터페이
      스를 묶어 관리하도록 하며,
	  개발이 끝난 후 jar파일로 묶어 배포한다.
   4) 패키지 구성
  -------------------------------
	   package 패키지이름;
	   import java.util.*;
	   class Test
	   {
	   }
  -------------------------------
  패키지 선언은 최상단에 위치해야 한다.
  -->import 문 보다도 먼저 와야 함.
  
  5)
  -예제 1 의 구조--> AAA.java/CCC.java 파일 참조
  myjava/day11[ROOT]
     |
	 +--myPack : 패키지
	     +----------AAA.java[AAA.class,BBB.class]
	     +----------CCC.java[CCC.class, DDD.class]

  - 예제2의 구조 [import문을 익히기 위한 예제]
->myjava/day11[루트]
	      |
		  +--pack : 패키지
			   + demo: 하위 패키지---Demo.java
		       +----------------------My1.java
			   +----------------------My2.java
		  |
		  +----TestPack.java [루트에 존재]

  -예제3의 구조[접근지정자 관련..]

myjava/day11[ROOT]
     |
	 +--myPack : 패키지
	 |    +----------AAA.java[AAA.class,BBB.class]
	 |    +----------CCC.java[CCC.class, DDD.class]
	 |
	 +--yourPack: 패키지
	      +----------FFF.java

		  :위 예제는 yourPack이란 패키지에 있는
		   FFF클래스에서 myPack의 AAA클래스와 BBB
		   클래스의 객체를 생성해 접근하려 할 때
		   의 예제이다.
		   AAA클래스의 접근지정자=> public
		   BBB클래스의 접근지정자=> 생략형
		                             :같은 패키지일
									 때만 접근 가능

**Access Modifier [접근지정자]의 접근 범위********
---------------------------------------------------------------
Modifiers|Same Class|Same Package|Sub Class| Universe
---------------------------------------------------------------
public   | yes		| yes		 |yes	   | yes									   
---------------------------------------------------------------
protected| yes		| yes		 | yes		|
---------------------------------------------------------------
default	 | yes		| yes		 |			|
---------------------------------------------------------------
private	 | yes		|			 |			|
---------------------------------------------------------------

  -예제3의 구조[접근지정자 관련...]
    ..-d옵션을 주어서 컴파일 해본다.
myjava/day11
       |
	   +--linux
	   |    +---java:패키지
	   |		 |
	   |		 +--Parent.java
	   |         +--Son1.java
	   |
	   +---windows
	        +----java:패키지
			      +--Son2.java
			   
////////////////////////////////////////
6. 추상클래스 (Abstract Class)
   
   - 한개 이상의 추상 메소드를 가지는 클래스

   - 추상메소드(abstract method)란?
     ...메소드 몸체(body)없이 선언만 하는 것
	    이 때 메소드 앞에 abstract 란 modifier
		를 붙여 준다.
		ex) abstract public void sub();

   - 추상메소드를 한개라도 가진 클래스는
     역시 class 앞에 abstract를 붙여주어
     추상 클래스로 만들어야 한다.

   - 추상 클래스를 상속받은 클래스에서는
     추상 메소드를 강제적으로 오버라이딩해야
	 한다. 그렇지 않을 경우 그 자식 클래스도 
	 추상 클래스가 되어야 함.

   - 추상 클래스는 타입선언은 할 수 있으나
     new 해서 객체 생성은 할 수 없다.
	 ...반드시 상속을 통해서만 완성됨.
	    상속받은 concrete 클래스로는 객체 생성
		이 가능하다.
----------------------------------------------------
일반 클래스의 멤버	|추상 클래스의	  |	인터페이스
(concrete class)	|(abstract class) | (interface
--------------------+-----------------+-------------
1. 멤버변수			|1 +2 +3 +4	+5 +6 |	1.final변수와
2. 클래스변수		|가 다 멤버로 들  | 2. 추상메소드
3. 생성자			|어가고 이에 추가 |로만 구성됨
4. 일반메소드		|로+ 7.추상메소드 |
5. 클래스메소드		|가 추가됨		  | 
6. final변수	등	|				  |
--------------------+-----------------+-------------

7. final 지정자(modifier)
   -final 지정자는 abstract 와 반대 개념으로
    이해하자.

--------------------------------------------
	  |	abstract		|  final
------+-----------------+-----------------------
클래스| 상속받게 할 목적| 상속을 못받게함
------+-----------------+-----------------------
메소드|강제로 오버라이딩| 오버라이딩을 못하게
      | 시키려는 목적   |
------+-----------------+-----------------------
변수  |    x            | 값할당 못하게 상수로
      |                 | 만듬
	  |				    | final public static을
	  |                 | 함께 쓴다.
------+-----------------+-----------------------

8. 인터페이스 (interface)

  - 모든 메소드가 추상메소드이고,
    모든 속성이 상수(final 변수)로 구성된 틀
	: 멤버가 추상메소드+ 상수로만 구성됨.

  - 인터페이스를 상속받을 때는 implements 란
    키워드를 사용한다.

  - 인터페이스는 다중 상속이 가능

  - 인터페이스에 있는 추상메소드는 abstract
    란 키워드를 생략한다...너무나도 당연하기에

  - 인터페이스의 변수 또한 public static final
    을 생략해도, 컴파일러가 자동으로 붙여준다.

  - 인터페이스 구현 방법---------------------
     interface MyInter{
		  void sub(); 
		  //추상메소드---public과 abstract를
		  //			생략해도 자동으로 붙는다.
     }
	------------------------------------
	class MyClass implements MyInter
	{
		//인터페이스를 상속받으면 반드시 
		//추상메소드를 오버라이딩 해야 한다.
		public void sub(){
			System.out.println("sub()");
		}
	}
	- 인터페이스가 인터페이스를 상속받을 때는
	  extends라는 키워드를 사용하며,
	  이 때 extends 로 여러 개의 인터페이스를
	  상속받는 것이 가능하다.
	  ex)
	  interface MyInter3 
				extends MyInter1, MyInter2{
			void func();
	   }
	- 인터페이스도 타입 선언은 할 수 있으나,
	  new 해서 객체 생성은 할 수 없다.
	  반드시 그 인터페이스를 상속받은 자식 클래스
	  객체로 생성해야 한다.

  ***인터페이스를 사용하는 이유***************
  인터페이스를 상속받은 클래스들에 대해
  인터페이스 레퍼런스를 통해 동일하게 접근할
  수 있기 때문
  *********************************************
9. 애플릿(Applet)
1) 자바 프로그램 종류
		|
		+--Application -- Console Application
		|			|
		|			+---- GUI Application
		|	        : 독립적인 실행 프로그램
		|			   java란 명령어로 실행가능
		|
		+--Applet : 비독립적인 프로그램
		            웹문서에 포함되어 실행된다.
					- appletviewer명령어로 실행
					- 웹브라우저를 통해 실행
					  ...웹브라우저 내에
					     탑재된 JVM을 통해 실행

2) 애플릿 작성시 주의 사항
----------------------------------------------
Applet					| Application
------------------------+----------------------
1) 반드시 클래스 속성을	| public, 디폴트 중 하나
   public 으로 줘야 함  |(단 내부클래스는 private
					    |  protected도 가능)
------------------------+----------------------
2) import java.applet.* |플마다 필요한 클래스 import
------------------------+----------------------
3) Applet 클래스를 상속 |플마다 필요한 클래스 상속
------------------------+----------------------
4) 기본 메소드를 가지고 |기본적으로 실행 프로그램은
   있다.                | main()메소드를 가져야 한다.
   init()/start()/	    |
   paint()/stop()/      |
   destroy()            |
------------------------+----------------------
5) 애플릿을 포함시킬    |main()메소드를 가진 클래스
   웹문서(html)가 필요  |에서 단독 실행 가능
------------------------+----------------------


9. java.awt.패키지의 컴포넌트 상속도
...정리
10. LayoutManager(배치관리자)
	- 정의 : Component를 Container에 배치할 때
			배치(Layout)에 관한 일정한 틀
    - 종류 :
	  1) BorderLayout
	  2) FlowLayout
	  3) GridLayout
	  4) CardLayout
	  5) GridBagLayout 등...

  1) BorderLayout : Window계열의 컨테이너(Frame,
					Dialog)의 디폴트 레이아웃
					동,서,남,북 영역을 가지고 배치

  2) FlowLayout  : Panel 계열의 컨테이너(Panel,
					Applet)의 디폴트 레이아웃
					물 흘러가듯 배치

  3) GridLayout : 행 열의 형태로 배치

  4) CardLayout : 카드를 포개어 놓듯 배치
  ***위의 레이아웃 객체들은 setLayout()이란 메소드
     를 통해 설정할 수 있다.

11. AWT 이벤트 처리 
  1) 이벤트(Event)란?
      ...프로그램과 관련있는 사건
	     ex)- 사용자가 버튼을 누르는 사건
		    - 마우스를 움직이는 사건
			- 텍스트필드에서 입력후 엔터를
			  치는 사건...등...
  
  2) 이벤트 처리를 위한 기본 개념

	i)  이벤트소스(Event Source)
	ii) 이벤트(Event)
	iii)이벤트 처리자(Event Handler)

	**위에서 프로그래머가 신경 쓸 부분은
	   Event Source 와 Event Handler 이다.
	   Event 는 JVM이 알아서 객체를 생성해
	   발생시킨다.

   i) Event Source
      - 이벤트를 발생시키는 근원지
	    ..컴포넌트나 컨테이너가 이벤트 소스가
		  됨 ex) Button, TextField, Panel 등...
   ii) Event
      - 이벤트 소스에 따라 발생되는 Event가 
	    달라진다.
		즉, 
		Button 일 경우 ActionEvent가 발생되며
		Checkbox일 경우는 ItemEvent가 발생된다.
		..각 이벤트 객체는 JVM이 발생시킨다.
   iii) Event Handler
       - Event를 처리해주는 클래스를 의미한다.
	   - 프로그래머가 직접 구현해주어야 하는
	     클래스이다.
       - 이벤트 핸들러가 되기 위해서는
	     XXXListener란 인터페이스를 상속받아야
		 한다.
		 ex)-Button 일 경우 --> ActionEvent 발생
			 --->  ActionListener 를 상속받는
				  클래스를 구성해야 함.
            -Checkbox --> ItemEvent 발생
			----> ItemListener 를 상속받는 클래스
			      구성
       - 각각의 리스너를 상속받은 클래스에서는
	     의무적으로 추상메소드를 재정의해야 한다.
		 이 메소드가 바로 이벤트를 처리해주는
		 메소드가 된다.
		 ex) ActionListener -> actionPerformed()
		     ItemListener -> itemStateChanged()
*********************************************
이벤트 소스가 결정되고
이벤트 핸들러를 구성했다면
이벤트 소스와 핸들러를 연결해줘야 한다.
-->addXXXListener()메소드를 이용
   ex)bt.addActionListener(핸들러객체)
***********************************************
3) Event 처리 절차
  1> import java.awt.event.*;
  2> XXXListener 인터페이스를 상속
  3> 2번이 가지고 있는 추상 메소드 재정의
  4> 이벤트소스와 핸들러를 연결해줌
     ...addXXXListener()메소드로.
  5> 3번에서 재정의한 메소드에 구체적인
     이벤트 처리 코드 구현

4) Event 핸들러를 구성하는 방법
   1> 이벤트소스(컴포넌트)를 가지는 자기 클래스
      가 핸들러가 되는 방법
   2> 이벤트 핸들러를 내부클래스(Inner class)로
      별도로 구성하는 방법
   3> 이벤트 핸들러를 외부클래스로 구성하는 방법

5) 이벤트 관련 Interface와 Adapter클래스
------------------------------------------------------------------------------
이벤트			|인터페이스				|추상메소드				|어댑터 클래스
----------------+---------------------+--------------------+-------------
ActionEvent	|ActionListener		 |actionPerformed()|  X
---------------+---------------------+---------------------+-------------
ItemEvent		|ItemListener			|itemStateChanged()|  X
---------------+---------------------+--------------------+-------------
Adjustment  |AdjustmentListener|adjustmentValue	|  X
Event			   |							   |Changed()				|
---------------+--------------------+---------------------+-------------
WindowEvent |WindowListener | windowClosing()	 	|WindowAdapter
					|						| windowClosed()		|
					|						| widnowOpened()		|
					|						| windowIconified()		|
					|						| windowDeiconified()|
					|						| windowActivated()	|
					|						| windowDeactivated()|
---------------+------------------+---------------------+-------------
MouseEvent  |MouseListener	 | mouseEntered()	|MouseAdapter
					|						| mouseExited()		|
					|						| mouseClicked()	|
					|						| mousePressed()	|
					|						| mouseReleased()	|
					+----------------------------------------------
					|MouseMotionListener| mouseDragged()|MouseMotionAdapter
					|								| mouseMoved()	  |
---------------+-------------------------+------------------+-------------









12. Exception (예외)

 1) 예외란?
	...프로그램이 진행하는 과정에서 만나게
	   되는 오류(가벼운 정도의 에러)
 2) 예외 관련 상속도
		Object
		  |
		Throwable
		|		|
      Error		Exception
					|
					+--RuntimeException
					|		+---NullPointerException
					|		+---ArithmeticException 
					|       +---ArrayIndexOutOfBoundsException
					|		+--- 등...런타임 예외
					|
					+--IOException
					|
					+--..등 컴파일타임에
					      체크되는 Exception
  3) 예외 처리 목적
	...프로그램 진행시 발생할 수 있는 상황들을 미리
	   정해놓고, 해당하는 예외가 발생했을 경우
	   적절한 조치를 취해서 프로그램이 정상적으로 
	   작동하도록 하기 위함

  4) 예외 처리 방법
     1> Handle하는 방법: 직접 처리하는 방법
	                      try~catch 절을 이용

     2> Declare하는 방법: 선언하는 방법
	                      throws 절을 이용

  5) 1>번째  방법-구체적인 예외 처리가 가능하다.

		try
		{
			예외 발생 코드
		}
		catch (해당예외클래스  e)
		{
			예외 처리 코드
		}
      2>번째 방법-예외 처리를 직접하지 않고
				   메소드를 호출하는 쪽으로
				   넘긴다.
			
			예외 발생 메소드 throws 해당 예외 클래스
			ex)
			public void sub() 
				throws IOException{
			}
			--->위 처럼 선언하면, sub()를 호출하는
			    쪽으로 IOException 을 넘겨준다.

        **RuntimeException계열 예외들은******
		  throws 를 안해줘도 JVM이 알아서 
		  throws 를  해주므로 생략해도 됨.
		**************************************

  6) 하나의 메소드에서 두개 이상의 Exception이
     발생할 경우
	 --> catch절을 여러 개 사용할 수 있다.
	 이 때 주의*************************
	 catch 절로 Exception을 잡을 때는
	 하위클래스(자식클래스)부터 잡아준다.
	 ************************************
  7) finally 절
    ...try절이 나와야 쓸 수 있는 구문으로,
	   try구문이 수행된 후, 또는 catch구문이
	   수행된 후에 반드시 한번은 수행되는
	   블럭이다.
	   [심지어 return 문이 오더라도 finally블럭은
	    반드시 실행된다. 단 System.exit(0)의 경우
		는 실행되지 않고 종료된다.]
**************************************************
예외 관련 문제]
... 다음 결과를 예측해서 출력될 output(결과)를
    기재해 보세요.
 try
 {
 	1번>...이 부분에서 AException이 발생했다면?
	//-->AException 발생,반드시 한번 수행코드,The End~~
    2번>...이 부분에서 BException이 발생했다면?
	//-->BException 발생,반드시 한번 수행코드
    3번>...이 부분에서 CException이 발생했다면?
	//-->CException 발생
	4번>...이 부분에서 기타 Exception이 발생했다면?
	//-->암튼...예외 발생,반드시 한번 수행코드,The End~~
 }catch (AException e){
	System.out.println("AException 발생");
 }catch(BException e){
	System.out.println("BException 발생");
	return;
 }catch(CException e){
	 System.out.println("CException 발생");
	 System.exit(1);
 }catch(Exception e){
	 System.out.println("암튼...예외 발생");
 }finally{
	 System.out.println("반드시 한번 수행코드");
 }
 System.out.println("The End~~!");
---------------------------------------------------
  8) 사용자 정의 예외 클래스 만들기
	- Exception을 상속받는 클래스를 만든다.
	- 생성자를 구성하고, 생성자 안에서
	  super(예외 메시지);를 호출한다.
	  -->여기에 들어간  예외 메시지가
	     getMessage()를 호출할 때 반환되는 
		 메시지가 된다.
    - 옵션: toString()메소드를 오버라이딩해
	     예외 관련 정보를 문자열로 돌려준다.

    ex) class NotKongException extends Exception
    {
		public NotKongException(){
			super("콩씨는 등록할 수 없어요!");
		}
    }/////////////////////////////////////////
  9) 사용자 정의 예외 클래스를 사용할 때는...
     위에서 만든 NotKongException을 사용해보자.
	 class Site
	 {
		 public void login(String name)
			 throws NotKongException{//////
			 if(name.startsWith("콩")){
				 throw new NotKongException();///
				 //throw와 throws가 쌍으로 존재
			 }
		 }
	 }//////////////////////////////////
	 사용자 예외 클래스 객체를 생성해서
	 throw 라는 키워드로 던져주고,
	 반드시 메소드 헤더부분에 해당 예외를
	 throws 해줘야 한다.
    
----------------------------------------------
13. paint()/repaint()/update()메소드 관계

	1) paint()메소드 : 프로그래머가 직접 호출
	                   할 수 없다.
					   JVM이 호출해주는 메소드
					   프로그래머는 오버라이딩만
					   할 뿐...

	그러나 paint()작업을 다시 해야 할 때가 있다.
	그럴 때는 repaint()메소드를 호출하자.

    2) repaint()메소드: 프로그래머가 호출할 수
	                    있는 메소드.
						repaint()를 호출하면,
						JVM이 자동으로 paint()
						메소드를 호출해준다.

   3) update()메소드 : 
   프로그래머가 repaint()를 호출하면 JVM은 paint()
   를 호출하기에 앞서, update()메소드를 호출한다.

   update()메소드에서 하는 일은
	i) 배경색으로 모두 지워준 뒤
	ii) paint()를 호출하는 일을 한다.

즉..repaint()를 호출하면

repaint()-->update(Graphics g)
				+--->지우기-->paint(g)
개발자--->| JVM--->
////////////////////////////////////////
14. Inner Class (내부클래스, 중첩클래스,Nested Class)

  1) 정의
	 ... 클래스 안에 클래스를 구성하는 것
  2) 종류
     ... 클래스가 정의되는 위치에 따른 분류
		  |
		  +--i) Inner Member 클래스
		  |            +---a) non-static클래스
		  | 		   +---b) static 클래스
		  |
		  +--ii)Inner Local 클래스
					   +--a) Named Local Class
					   |      (이름있는 로컬 클래스)
					   +--b) Anonymous Class
					          (이름 없는 클래스,
							    익명클래스, 
								무명안긴 클래스)
  3) Inner 클래스 객체생성 방법 및 사용법
     ...> Outer.java 예제, Local.java

 4) 로컬 이너 클래스는
    a) 이름있는 로컬 이너 클래스
	b) 이름없는 로컬 이너 클래스
	로 구분할 수 있는데, 로컬 클래스는 지역변수와
	비슷한 성격을 가지며, 활용범위가 정의되는 메소드
	블럭 내부로 제한 된다.

	로컬 클래스는 외부(Outer)클래스의 멤버변수와,
	메소드의 final 로컬변수, 그리고 final 매개변수
	의 사용이 가능하다.(로컬 클래스가 메소드의 
	지역변수 값을 변화시키지 않기 위해서...)

	a)이름있는 로컬 이너 클래스의 경우

	  - 우선 정의를 한 다음에만 사용할 수 있다.
	  - 다른 클래스의 상속이 불가능하다.
	  - 컴파일 하면 OuterClass$숫자+로컬클래스명
	    의 클래스 파일이 생성된다.
		여기서 숫자는 인덱스를 의미하는데, 서로 
		다른 메소드인 경우 동일 명칭의 클래스가
		존재할 수 있기 때문에 중간에 인덱스 역할
		의 숫자를 붙여 구분되도록 한다.

	b)이름없는 로컬 이너 클래스(Anonymous 클래스)

	   - 이름을 갖지 않는 이너 클래스
	   - 한번만 객체 생성이 가능하다.
	   - 객체를 생성하는 문장 뒤에 클래스의 블럭
	     을 덧붙이는 방법으로 구성
       - new 키워드 뒤 생성자의 명칭이 기존 클래스
	     명일 경우에는 Anonymous클래스가 자동적으로
		 클래스의 자식 클래스가 되며,
		 인터페이스일 경우에는 이 인터페이스를 상속
		 하는 클래스로서, 부모 클래스가 Object이 된다.
////////////////////////////////////////
15.	java.lang.Thread 클래스 사용하기

    1)Process 란?
	  ...컴퓨터 내에 실행 중인 프로그램을 의미
	     프로세스는 각각 독립된 주소공간을 가지고
		 실행되며, 서로 독립적으로 실행되도록
		 스케줄링 할 수 있다.

	2) Thread 란?
	  ...하나의 프로세스 안에서 실행되는 명령 흐름
		 (프로세스 안의 작은 프로그램)
	     스레드는 자신의 주소공간을 갖지 않고, 
		 실행될 때 그 프로세스의 메모리와 자원을
		 사용한다.


	- Multi Tasking : 동시에 word, exel, jvm이
	                  작업하는 것처럼 보이는 것.

	- Multi Processing: 아예 동시에 작업 실행하는 것.
						일반적인 개인용 컴퓨터에서는
						cpu가 하나만 들어있지만,
						중대형 컴퓨터에서는 여러 개의
						cpu를 사용하는 경우가 많다.
						여러 개의 cpu에서 동시에
						여러 개의 프로세스가 수행되
						는 것을 멀티 프로세싱이라 함
					
	- Multi Threading : 프로세스 안에서 여러 개의
						스레드가 동시 작업하는 것.
						즉 한 프로그램 내에서 두가지
						이상의 일을 수행하는 것으로서,
						
						ex) 워드를 치면, 자동교정,
						    자동 저장, 타이핑 등
							작업이 동시에 이뤄지는데
							이는 멀티 스레딩의 예.

3) 스레드를 작성하는 방법

	1> java.lang.Thread 클래스를 상속받아 구현
	2> java.lang.Runnable 인터페이스를 상속받아 구현

	1>Thread를 상속받는 경우
		....run()메소드 오버라이딩.
		class SnailThread extends Thread
		{
			public void run(){
				//스레드가 할 일을 구성			
			}
		}///////////////////////////////
		**SnailThread를 사용하는 응용프로그램에서
		  는 아래와 같이 사용한다.
		  SnailThread tr=new SnailThread();
		  tr.start();/		  //run()을 호출하는 것이 아니라,
		  //start()를 호출함으로써 Thread가 실행된다.
     
	 2> Runnable을 상속받는 경우
		...역시 run()메소드를 오버라이딩
	 class Snail implments Runnable
	 {
		 public void run(){
			// 스레드가 할 일을 구성
		 }
	 }/////////////////////////
		**응용 프로그램에서는 아래와 같이 사용
		Snail r=new Snail();
		Thread tr=new Thread(r);
		tr.start();
****************************************************
- 스레드를 상속받는 경우: 클래스와 무관하게 독립된
	작업을 하거나, 여러 개의 스레드가 필요한 경우에
	적합하다.
- Runnable을 상속받는 경우: 클래스 특성을 그대로 유지
	하면서 스레드를 하나씩 생성할 수 있다는 장점이
	있다.
******************************************************
4) Thread의 주요 메소드

  1> start() : start했다고 해서 바로 run하는 것이 아님
      단지 run을 준비하는 상태로 들어감
  2> activeCount()
  3> currentThread()
  4> setName()
  5> getName()
  6> sleep() : 자기보다 낮은 순위의 스레드에게 실행기회
      를 준다.
  7> yield() : 자기와 우선순위가 같거나 높은 스레드에게
      실행기회를 준다.
  8> join()  : 칠판 설명을 참조..
  9> interrupt(): sleep()및wait()메소드가 수행중일 때,
     이 메소드를 호출하면 interruptedException이 
     발생된다.
 10> wait()  : 동기화 블럭
 11> notify() : 동기화 블럭
 12> notifyAll() : 동기화 블럭

 13> stop(): 스레드 강제종료-Depricated됐으므로 
 사용하지 말자.
 14> setPriority()
 15> getPriority()
 16> isAlive() : alive는 스레드가 run상태에 있다는
     것을 의미하는 것이 아님. 단지 스레드가
     start되었고, stop되거나 run off되지
     않았다는 것을 의미.

5) Thread 의 주요 상수
 1) Thread.MAX_PRIORITY : 10
 2) Thread.MIN_PRIORITY : 1
 3) Thread.NORM_PRIORITY: 5

6). 주의 사항
   - wait()/notify()/ notifyAll() 메소드는 
     synchronized 블럭이나 코드에서 수행되어야 한다.
 **synchronized(동기화)란?***
   ...코드의 한 부분이 다른 스레드와 동시에 수행
      될 수 없게 하는 것.
   synchronized 란 키워드는 modifier의 일종으로
   동기화 블럭을 만들때 사용한다.

7). 스레드를 종료시키려면?

   1> stop() 호출: 강제종료 -> 사망
                  1)의 방법은 문제점이 있으므로 지양
   2> interrupt()메소드를 사용해서 처리하는 방법
   3> 상수를 이용하는 방법
 --> 스레드를 이용한 애플릿 예제 참조

 8)스레드 동기화(synchronized);

...어느 주어진 시간에는 하나의 스레드만이 동일한
   자료를 참조할 수 있도록 제한하는 방법

   -synchronized 는 메소드에 사용이 가능한 modifier
    로서, 여러 스레드에 의해 특정 객체의 메소드들이
	동시 호출되는 것에 대해 잠금(lock)을 설정하여,
	거부하도록 하는 기능을 지원한다.

   - 즉 코드의 한부분, 또는 동기화된 메소드가
     다른 스레드와 동시에 수행될 수 없게 하는 것
 
 9) synchronized 구현 방법

	1> synchronized 블럭을 이용

	   ex) public void push(char c){
				////////
			synchronized(this){
				동기화 블럭

			}//////////////////
	   }//-----------------------

    2> 메소드 앞에 synchronized 지정자를 붙임
	   ex)
	   synchronized public void push(char c){
			동기화된 메소드
		}//-------------

	...2>의 방법을 이용할 경우, 메소드 전체가 동기
	     화 블럭이 되어, 필요 이상으로 엄격하게
		 lock flag를 유지하고 있는 결과를 초래.


  10) wait()/ notify() /notifyAll() 메소드
	...동기화 블럭에서 수행되는 메소드
	   -> 그렇지 않으면 IllegalMonitorStateException
	      발생
      - wait() 메소드 사용시 InterruptedException
	    이 발생할 수 있으므로, 예외 처리를 해줘야 함.

		1> wait() 가 호출되면...
		  - 수행 권한을 포기한다.
		  - 모니터 락(lock)을 반납한다.
		  - 대기상태(Waiting Pool)로 들어간다.

        2> notify()가 호출되면...
		  - Waiting Pool에 들어가 있는 스레드 하나를		    
			Runnable 한 상태로 전환시킨다.
          - notify()는 특정 스레드를 깨워주는 것이
		    아니라, wating pool에 있는 아무 스레드나
			깨울 수 있음
          - 반면 notifyAll() 메소드는 waiting pool에
		    있는 모든 스레드를 깨워준다.

  11) DeadLock 이란?
      ... 두 스레드간의 상호 의존에 기인하는 버그
	      다중 스레드가 다중 자원에 접근하기 위해
		  경쟁하는 프로그램에서 DeadLock이 발생할
		  수 있다.

		  ex) 칠판 그림 참조...
		  설계 단계에서부터 DeadLock을 방지하는
		  설계를 해야 함.
				
16. java.util.Vector 클래스--> 참조형만 저장 가능
	- 객체를 저장할 수 있는 클래스
	- 배열과 기능면에서 유사

	cf> 배열->기본자료형, 참조형 저장 가능
	     - 같은 타입의 데이터만 저장
		 - 고정 크기 : 일단 생성된 후에는
					   배열 크기를 변경하기 불가능
					   int a[]=new int[3];

    반면 Vector 는
		ex) Vector v=new Vector(3, 2);
										//3-> 용량, 2->증가치

	 - Object 유형의 Collection 으로서,
	   어떤 유형의 객체도 저장할 수 있다.
	   [단, 기본자료형은 저장 불가.]
	 - 벡터는 데이터가 가득 차면 자동으로
	   저장 영역을 확대한다.
	 - java.util.List 인터페이스를 구현하는 클래스로
	   순서대로 정렬되고, 중복도 허용하는 특징
	   을 갖는다.

   1) Vector 클래스 생성자
      1> Vector()//10개 요소를 저장할 공간
	  2> Vector(int initialCapacity)//초기치 용량을 매개변수로 정할 수 있다.
	  3> Vector(int initialCapacity, int incre)
	      : 초기 용량과 증가치를 인자로 넣어줌

   2) Vector에 요소 저장
   ex) Vector v=new Vector(5);
		 v.add("Hello");
		 v.add(new Integer(10));
							0         1
		 v------->| "Hello"  |  10   |

      1> add(Object obj)
	  2> addElement(Object obj)

   3) Vector에서 꺼내오기
		ex)    Object obj=  v.get(0);
				String str=(String)obj;
			
				Integer i=(Integer)v.get(1);

      1> Object get(int index)
	  2> Object elementAt(int index)
	  3> Enumeration elements();
   4) elements()/iterator()로 벡터 요소 꺼내오기.
	
	- Enumeraiont과 Iterator인터페이스는 객체들을
      집합체로 관리하는데, 이들 인터페이스에는
      각각의 객체들을 한순간에 하나씩 처리할 수
      있는 메소드를 제공한다.

	-Vector의 메소드 : Enumeration elements()
	/******************************************
	Enumeration인터페이스에 있는 주요 메소드
	  1>boolean hasMoreElements()  
	  2> E nextElement() 
	******************************************/
	-Vector의 메소드 : Iterator iterator()
	/******************************************
	Iterator 인터페이스의 주요 메소드
	  1>  boolean hasNext() 
	  2> E next()
	  3> void remove() 	
   ******************************************/

******************************************************
**java.util.객체 저장 클래스
1) Collection 계열
		Collection
		 |		|
	   Set		List
	     |
	SortedSet
	1>특징 
	  - 객체 입력 순서를 기억
	  - 중복을 허용
    2> 하위의 주요 클래스
	   - ArrayList, Vector

2) Map 계열
		Map
		|
     SortedMap
	 1> 특징
	   -Object유형(객체형)의 key와 value가
	    매핑(mapping)되어 저장
       - key값은 중복되어선 안된다.
	     [value는 중복 허용]
     2> 하위의 주요 클래스
		-Hashtable, Properties
/////////////////////////////////////////////////////////////////
# Eclipse 설치
[1] 다운로드
	http://www.eclipse.org
	http://www.eclipseplugincentral.com
	http://eclipse-plugins.2y.net/eclipse/index.jsp
[2] 다운로드시 참고 사항
	- Release: 개발팀이 주요 릴리즈로 인정한 버전
	- Stable Build: Integration빌드 중에서 대부분 사용자가 안정적으로 사용할 수 있다고 평가된 버전
	- Integration Build: 각 컴포넌트에서 안정적이라 평가된 버전을 주기적으로 통합하여 만든 버전
	- Nightly Build: 수정 여부에 관계 없이 매일 밤에 빌드한 버전. 이클립스 프로젝트에 직접 참여한 개발자에게만 유용한 버전이다.
    
[3] 우리가 설치할 이클립스는
     웹개발툴-lomboz을 포함하는 all-in-one
	 http://lomboz.objectweb.org 에서 다운로드 받는다.
	 최근 버전보다는 한단계 낮은 버전을 설치한다...플러그인 개발이 다소 늦으므로..

[4] plug-in
1> VE 플러그인
1) 다운로드 사이트
http://www.eclipse.org/vep/WebContent/main.php
2)VE v1.2 final release June 30, 2006 링크 클릭
3)VE-runtime-1.2.zip 링크 클릭하여 다운로드
--> c:/java/myjava/util/아래 둔다.
4) zip파일의 압축을 푼다.
5) 압축을 풀면 eclipse폴더가 있는데 그 안에
있는 모든 폴더(features, plugin)를 복사하여
우리가 설치한 이클립스 안에 들어가 붙여넣기 한다.
...c:/java/eclipse/안에 붙여넣기.
모두 덮어쓰기를 선택한다.
6) 실행중인 이클립스를 끄고 다시 실행시킨다.



////////////////////////////////////////////////////




# Applet의 보안
- 애플릿은 클라이언트 쪽에 다운로드 되어 실행되는 프로그램으로
   만일 애플릿 프로그램이 응용 프로그램처럼 작성되었다면
   심각한 문제가 발생할 수 있다.
   인터넷을 통해 다운된 애플릿 프로그램이 사용자 컴퓨터의
   디스크에서 정보를 읽거나 파일에 새로운 내용을 쓴다면
   심각한 문제가 아닐 수 없다.
   이러한 문제점 때문에 웹브라우저나 사용자 컴퓨터의 운영체제
   는 애플릿 프로그램에 다음과 같은 제한을 두고 있다.

1] 애플릿은 다운로드된 컴퓨터의 지역 프로그램을 실행시킬 수 
    없다.
2] 애플릿들은 다운로드되는 서버가 아닌 다른 컴퓨터와의 통신은
    허용하지 않는다.

3] 애플릿은 다운로드된 컴퓨터의 파일 시스템에 접근할 수 없다.
4] 애플릿들은 다운로드된 컴퓨터의 정보를 알 수 없다.
  (예외: 웹브라우저 버전, 운영체제 이름과 버전, 경로등은 알 수
           있음)
- 만일 애플릿 프로그램이 사용자 컴퓨터의  디스크를 읽거나
  쓰는 동작을 취한다면, 웹브라우저는 보안(Security) 관련
  에러를 출력시키고, 애플릿의 수행을 중단한다.











